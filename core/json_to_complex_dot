import json
from typing import Dict, List

forward_node_name = "[forward]"
backward_node_name = "[backward]"

class TensorInfo:
    producer: int
    comsumers: List[int]
    label: str

    def __init__(self, tensor: Dict):
        self.producer = -1
        self.comsumers = []
        self.label = f'{tensor["shape"]}'

def is_leaf(node: Dict) -> bool:
    return node["is_leaf"]

def get_tensor_key(tensor: Dict) -> str:
    return f'{tensor["id"]}_{tensor["version"]}_{tensor["device"]}'

def preprocess_tree(tree_dict: Dict[int, Dict]) -> None:
    max_id = -1
    forward_root_node: Dict = {
        "id": -1,
        "name": forward_node_name,
        "start_time": -1,
        "end_time": -1,
        "is_leaf": False,
        "is_backward": False,
        "parent": None,
        "children": []
    }
    backward_root_node: Dict = {
        "id": -1,
        "name": backward_node_name,
        "start_time": -1,
        "end_time": -1,
        "is_leaf": False,
        "is_backward": True,
        "parent": None,
        "children": []
    }

    for id, node in tree_dict.items():
        max_id = max(max_id, id)
        if node["parent"] is not None:
            continue
        if node["is_backward"]:
            backward_root_node["start_time"] = min(backward_root_node["start_time"], node["start_time"]) if backward_root_node["start_time"] != -1 else node["start_time"]
            backward_root_node["end_time"] = max(backward_root_node["end_time"], node["end_time"]) if backward_root_node["end_time"] != -1 else node["end_time"]
            backward_root_node["children"].append(id)
        elif not node["is_backward"]:
            forward_root_node["start_time"] = min(forward_root_node["start_time"], node["start_time"]) if forward_root_node["start_time"] != -1 else node["start_time"]
            forward_root_node["end_time"] = max(forward_root_node["end_time"], node["end_time"]) if forward_root_node["end_time"] != -1 else node["end_time"]
            forward_root_node["children"].append(id)

    # 增加两个节点的id
    forward_root_node["id"] = max_id + 1
    backward_root_node["id"] = max_id + 2
    for id, node in tree_dict.items():
        max_id = max(max_id, id)
        if node["parent"] is not None:
            continue
        if node["is_backward"]:
            node["parent"] = backward_root_node["id"]
        elif not node["is_backward"]:
            node["parent"] = forward_root_node["id"]

    # 添加两个根节点
    tree_dict[forward_root_node["id"]] = forward_root_node
    tree_dict[backward_root_node["id"]] = backward_root_node

def json_to_complex_dot(graph_data: List[Dict], tree_data: List[Dict]) -> str:
    # 1.每条json数据以id为key
    leaf_node_map: Dict[int, Dict] = {n["id"]: n for n in graph_data}
    node_map: Dict[int, Dict] = {n["id"]: n for n in tree_data}

    preprocess_tree(node_map)

    # 对森林设置一个总的虚拟的根节点，id为-1，方便后续算法计算
    virtual_root_id = -1

    # 2.获取tensor的生产者和消费者节点id

    # 数据保证tensor最多只有一个生产者，如果没有生产者则设为-1，消费者可能有多个，如果没有消费者则为空list
    # tensor不会生产者、消费者均没有
    tensor_map: Dict[str, TensorInfo] = {}
    for node_id, node in leaf_node_map.items():
        for tensor in node["in_edges"]:
            tensor_key = get_tensor_key(tensor)
            if tensor_key not in tensor_map:
                tensor_map[tensor_key] = TensorInfo(tensor)
            tensor_map[tensor_key].comsumers.append(node_id)
        for tensor in node["out_edges"]:
            tensor_key = get_tensor_key(tensor)
            if tensor_key not in tensor_map:
                tensor_map[tensor_key] = TensorInfo(tensor)
            tensor_map[tensor_key].producer = node_id

    # 3.推导tensor属于哪个子图中，tensor属于某一个子图即tensor的所有生产者和消费者均在该子图中
    # 获取祖先列表函数
    def get_ancestors(op_id):
        ancestors = []
        while True:
            ancestors.append(op_id)
            if node_map[op_id]["parent"]:
                op_id = node_map[op_id]["parent"]
            else:
                break
        return ancestors

    def find_subgraph_id(producer_id: int, comsumer_ids: List[int]) -> int:
        # 与tensor相关联的op仅有一个（数据保证tensor必有关联的op）
        if producer_id == virtual_root_id or comsumer_ids == []:
            return virtual_root_id

        # 合并生产者消费者，合并后数量至少为2
        op_ids: List[int] = [producer_id] + comsumer_ids

        def get_ancestors(op_id):
            ancestors = []
            while True:
                ancestors.append(op_id)
                if node_map[op_id]["parent"]:
                    op_id = node_map[op_id]["parent"]
                else:
                    break
            return ancestors

        # 生成第一个节点的祖先链
        ancestors = get_ancestors(op_ids[0])
        ancestor_set = set(ancestors)

        # 对剩余节点，取祖先交集
        for op_id in op_ids[1:]:
            ancestor_set &= set(get_ancestors(op_id))

        # 从第一个节点的祖先链（自底向上）找第一个在交集里的
        for a in ancestors:
            if a in ancestor_set:
                return a

        # 无共同祖先
        return virtual_root_id

    tensors_in_subgraph: Dict[int, List[str]] = {}
    for tensor_key, tensor_info in tensor_map.items():
        subgraph_id = find_subgraph_id(tensor_info.producer, tensor_info.comsumers)
        if subgraph_id in tensors_in_subgraph:
            tensors_in_subgraph[subgraph_id].append(tensor_key)
        else:
            tensors_in_subgraph[subgraph_id] = [tensor_key]

    # 4.dfs遍历树并生成str
    dot_lines: List[str] = []

    # dfs遍历函数，每次调用处理一个子图
    def dfs(root_id: int, children: List[int], depth: int, ) -> List[str]:
        sub_dot_lines: List[str] = []
        for node_id in children:
            if is_leaf(node_map[node_id]):
                # 添加op
                sub_dot_lines.append(f'{"    "*depth}"node_{node_id}" [label="{node_map[node_id]["name"]}", shape=box];')
            else:
                # 添加子图
                sub_dot_lines.append(f'{"    "*depth}subgraph cluster_{node_id} {{')
                if node_map[node_id]["name"] == forward_node_name:
                    sub_dot_lines.append(f'{"    "*(depth+1)}rankdir=LR;')
                elif node_map[node_id]["name"] == backward_node_name:
                    sub_dot_lines.append(f'{"    "*(depth+1)}rankdir=RL;')
                sub_dot_lines.append(f'{"    "*(depth+1)}label="{node_map[node_id]["name"]}";')
                sub_dot_lines.append(f'{"    "*(depth+1)}style=rounded;')
                sub_dot_lines.append(f'{"    "*(depth+1)}color=blue;')
                sub_dot_lines += dfs(node_id, node_map[node_id]["children"], depth+1)
                sub_dot_lines.append(f'{"    "*depth}}}')

        # 添加tensor及其连线
        for tensor_key in tensors_in_subgraph.get(root_id, []):
            sub_dot_lines.append(f'{"    "*depth}"tensor_{tensor_key}" [label="{tensor_map[tensor_key].label}", shape=ellipse];')
            producer_id = tensor_map[tensor_key].producer
            if producer_id != virtual_root_id:
                sub_dot_lines.append(f'{"    "*depth}"node_{producer_id}" -> "tensor_{tensor_key}";')
            for comsumer_id in tensor_map[tensor_key].comsumers:
                sub_dot_lines.append(f'{"    "*depth}"tensor_{tensor_key}" -> "node_{comsumer_id}";')

        return sub_dot_lines

    root_nodes = [k for k, v in node_map.items() if v["parent"] is None]
    dot_lines = dfs(virtual_root_id, root_nodes, depth=1)

    # 5.定义dot文件头尾，完成组装
    root_dot_lines: List[str] = []
    root_dot_lines.append("digraph G {")
    root_dot_lines.append('  rankdir=LR;')  # 从左到右绘制
    root_dot_lines.append('  node [fontname="Arial"];')
    root_dot_lines.append("}")
    result = "\n".join(root_dot_lines[:3] + dot_lines + root_dot_lines[3:])

    return result
